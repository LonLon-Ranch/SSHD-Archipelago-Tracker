(function(){"use strict";function I(e,...t){}const x=BigInt(1),E=BigInt(0);function A(e,t){if(e.size>t.size){const n=e;e=t,t=n}return new Set([...e].filter(n=>t.has(n)))}function K(e,t){return new Set([...e,...t])}class S{constructor(t,n){this.data=t??E,this.intSet=n??new Set}setBit(t){return this.data|=x<<BigInt(t),this.intSet.add(t),this}clearBit(t){return this.intSet.has(t)&&(this.data=this.data-(x<<BigInt(t)),this.intSet.delete(t)),this}and(t){return new S(t.data&this.data,A(t.intSet,this.intSet))}or(t){return new S(t.data|this.data,K(t.intSet,this.intSet))}test(t){return this.intSet.has(t)}isSubsetOf(t){return this.numSetBits<=t.numSetBits&&(this.data|t.data)===t.data}equals(t){return this.data===t.data}toString(t){let n="";for(let i=t-1;i>=0;i--)this.data&x<<BigInt(i)?n+="1":n+="0";return n}clone(){return new S(this.data,new Set(this.intSet))}isEmpty(){return this.numSetBits===0}intersects(t){return!!(this.data&t.data)}iter(){return this.intSet.values()}getSingleSetBit(){return this.intSet.values().next().value}get numSetBits(){return this.intSet.size}}class a{static false(){return new a([])}static true(){return new a([new S])}constructor(t){this.conjunctions=t}or(t){return t instanceof S?new a([...this.conjunctions,t]):new a([...this.conjunctions,...t.conjunctions])}and(t){return t instanceof S?new a(q(this.conjunctions,[t])):this.isTriviallyFalse()||t.isTriviallyFalse()?a.false():new a(q(this.conjunctions,t.conjunctions))}drop_unless(t,n){return new a(this.conjunctions.map(i=>i.test(n)?i:i.clone().clearBit(t)))}removeDuplicates(){const t=[];t:for(let n=0;n<this.conjunctions.length;n++){const i=this.conjunctions[n],o=[];for(const[f,s]of t.entries()){if(s.isSubsetOf(i))continue t;i.isSubsetOf(s)&&o.push(f)}for(let f=o.length-1;f>=0;f--){const s=o[f];s===t.length-1?t.pop():t[s]=t.pop()}t.push(i)}return new a(t)}orExtended(t){const n=[...this.conjunctions],i=[];let o=!1;const f=t.conjunctions;t:for(let s=0;s<f.length;s++){const c=f[s];for(let r=0;r<n.length;r++)if(n[r].isSubsetOf(c))continue t;i.push(c),o=!0}return[o,new a([...n,...i])]}eval(t){return this.conjunctions.some(n=>n.isSubsetOf(t))}isTriviallyFalse(){return this.conjunctions.length===0}isTriviallyTrue(){return this.conjunctions.length>0&&this.conjunctions.some(t=>t.isEmpty())}clone(){return new a(this.conjunctions.map(t=>t.clone()))}}function q(e,t){const n=[];for(const i of e)for(const o of t)n.push(i.or(o));return n}function F(e){for(const[t,n]of e.entries())n.conjunctions.length>=2&&(e[t]=n.removeDuplicates())}function M(e,t){const n=t.map(()=>[]);for(const[o,f]of t.entries())if(!e.test(o)){for(const s of f.conjunctions)if(s.numSetBits===1){const c=s.getSingleSetBit();if(c===o||e.test(c))continue;n[c].push(o)}}let i=!1;for(let o=0;o<t.length;o++){const f=n[o];for(const s of f)R(t,o,s)&&(i=!0)}return i}function R(e,t,n){const i=e[t],o=e[n];if(i.conjunctions.length<2||o.conjunctions.length<2)return!1;const f=i.conjunctions.findIndex(u=>u.numSetBits===1&&u.test(n));if(f===-1||o.conjunctions.findIndex(u=>u.numSetBits===1&&u.test(t))===-1)return!1;const c=i.conjunctions.slice(),r=c.splice(f,1);for(const u of c)e[n]=e[n].or(u);return e[t]=new a(r),!0}function W(e,t){const n=new S;let i=!1;for(let o=0;o<t.length;o++)!e.test(o)&&t[o].conjunctions.length<=1&&n.setBit(o);for(const[o,f]of t.entries()){if(f.conjunctions.length>=30)continue;let s=a.false();for(const c of f.conjunctions)if(c.intersects(n)){i=!0;let r=new S,u=!1;for(const m of c.iter())if(!n.test(m))r.setBit(m);else{const w=t[m];if(w.isTriviallyTrue())continue;if(w.isTriviallyFalse()){u=!0;break}r=r.or(w.conjunctions[0])}!u&&!r.test(o)&&(s=s.or(r))}else s=s.or(c);t[o]=s}return i}function N(e,t){const n=t.map(s=>new a(s.conjunctions.filter(c=>!c.isSubsetOf(e)))),i=new S;for(const[s,c]of t.entries()){const r=new a(c.conjunctions.filter(u=>u.isSubsetOf(e)));t[s]=r,(!r.isTriviallyFalse()||e.test(s))&&i.setBit(s)}let o=!0,f;for(;o;){o=!1;const s=new S,c=f?f.and(i):i;for(const[r,u]of n.entries()){if(t[r].isTriviallyTrue())continue;let m=a.false();for(const d of u.conjunctions)if(d.isSubsetOf(i)&&d.intersects(c)){const l=new S;let p=a.true();for(const y of d.iter())if(e.test(y))l.setBit(y);else{const B=t[y];p=p.and(B).removeDuplicates()}for(const y of p.conjunctions)m=m.or(y.or(l))}const[w,g]=t[r].orExtended(m);w&&(s.setBit(r),o=!0,t[r]=g.removeDuplicates(),i.setBit(r))}f=s}}class h{constructor(t,n){this.items=t,this.type=n}static and(...t){return new h(t,"and")}static or(...t){return new h(t,"or")}isAnd(){return this.type==="and"}isOr(){return this.type==="or"}static isExpression(t){return typeof t=="object"&&t instanceof h}flatten(){const t=this.items.flatMap(n=>{if(!h.isExpression(n))return n;const i=n.flatten();return i.type===this.type||i.items.length===1?i.items:i});return t.length===1&&h.isExpression(t[0])?t[0]:new h(t,this.type)}simplify(){return this.flatten()}}function P(e,t){let n=e[0],i=-1/0;for(let o=0;o<e.length;o++){const f=e[o],s=t(f);s>i&&(i=s,n=f)}return n}function b(e,t){let n=0;for(let i=0;i<e.length;i++)n+=t(e[i]);return n}function k(e,t){if(t.length===0)return h.or();if(t.length===1&&t[0].isEmpty())return h.and();const n=new a(t).removeDuplicates().conjunctions;for(const r of n)for(const u of r.iter())for(const m of e.impliedBy[e.allItems[u]]??[]){const w=e.itemBits[m];w!==u&&r.test(w)&&r.clearBit(u)}if(n.length===1)return h.and(...[...n[0].iter()].map(r=>e.allItems[r])).simplify();let i=new Set(n[0].iter());for(const r of n)i=new Set([...r.iter()].filter(u=>i.has(u)));const o=new Set;for(const r of n){for(const u of i)r.clearBit(u);for(const u of r.iter())o.add(u)}const f=z(n,[...o],new S).filter(r=>!r.coKernel.isEmpty()),s=f.reduce((r,u)=>{for(const m of u.kernel)r.some(w=>m.equals(w))||r.push(m);return r},[]),c=f;if(c.length>0&&s.length>0){const r=Array(c.length).fill([]).map(()=>Array(s.length).fill(0));for(const[l,p]of s.entries())for(const[y,B]of c.entries())B.kernel.some(O=>O.equals(p))&&(r[y][l]=1);const u=l=>c[l].coKernel.numSetBits+1,m=l=>s[l].numSetBits,w=(l,p)=>c[p].coKernel.or(s[l]).numSetBits,g=(l,p)=>b(l,y=>b(p,B=>r[y][B]?w(B,y):0))-b(l,u)-b(p,m),d=[];if(Q(c.map((l,p)=>p),s.map((l,p)=>p),r,(l,p)=>(d.push([l,p]),!0)),d.length){const[,l]=P(d,([v,Y])=>g(v,Y)),p=l.map(v=>s[v]),{quotient:y,remainder:B}=U(n,p),O=new a(y).removeDuplicates(),J=[...i].map(v=>e.allItems[v]),V=h.and(k(e,O.conjunctions),k(e,p)),X=h.or(V,k(e,B));return h.and(...J,X).simplify()}}return h.and(...[...i].map(r=>e.allItems[r]),h.or(...n.map(r=>Z(e,r)))).simplify()}function Q(e,t,n,i){for(const o of e){const f=t.filter(s=>n[o][s]);f.length&&!e.some(s=>s!==o&&t.every(c=>!f.includes(c)||n[s][c]))&&i([o],f)}for(const o of t){const f=e.filter(s=>n[s][o]);f.length&&!t.some(s=>s!==o&&e.every(c=>!f.includes(c)||n[c][s]))&&i(f,[o])}D(e,t,n,0,[],[],i)}function D(e,t,n,i,o,f,s){for(const c of t)if(c>=i&&e.filter(r=>n[r][c]).length>=2){const r=n.map((g,d)=>n[d][c]?g.slice():g.map(()=>0)),u=e.filter(g=>n[g][c]),m=f.slice();let w=!1;for(const g of t)if(e.filter(d=>r[d][g]).length===e.filter(d=>n[d][c]).length)if(g<c){w=!0;break}else{m.push(g);for(const d of e)r[d][g]=0}w||s(u,m)||D(e,t,r,c,u,m,s)}}function z(e,t,n,i=[],o=0){const f=[];for(const[s,c]of t.entries()){if(s<o)continue;const r=e.filter(u=>u.test(c));if(r.length>=2){const u=r.reduce((d,l)=>d.and(l),r[0]),m=n.or(u),w=U(e,[u]).quotient,g=z(w,t,m,i,s+1);for(const d of g)i.some(l=>l.equals(d.coKernel))||(i.push(d.coKernel),f.push(d))}}return i.some(s=>s.equals(n))||f.push({kernel:e,coKernel:n.clone()}),f}function U(e,t){let n;for(const f of t){const s=e.filter(c=>f.isSubsetOf(c)).map(c=>c.clone());if(s.length===0)return{quotient:[],remainder:e};for(const c of s)for(const r of f.iter())c.clearBit(r);n?n=n.filter(c=>s.some(r=>r.equals(c))):n=s}const i=new a(n).and(new a(t)).removeDuplicates(),o=e.filter(f=>!i.conjunctions.some(s=>s.isSubsetOf(f)));return{quotient:n,remainder:o}}function Z(e,t){return h.and(...[...t.iter()].map(n=>e.allItems[n]))}function C(e){const t=[];for(const n of e){const i=new S;for(const o of n)i.setBit(o);t.push(i)}return new a(t)}function G(e){return T(e)}function T(e){if(h.isExpression(e))switch(e.type){case"and":return{type:"and",items:e.items.map(T)};case"or":return{type:"or",items:e.items.map(T)}}else return e}let j;self.onmessage=e=>{const t=performance.now();switch(e.data.type){case"initialize":{const n=new S;for(const f of e.data.opaqueBits)n.setBit(f);const i=e.data.requirements.map(C);j={logic:e.data.logic,opaqueBits:n,learned:new Set,requirementsForBottomUp:i};do for(F(j.requirementsForBottomUp);W(j.opaqueBits,j.requirementsForBottomUp);)F(j.requirementsForBottomUp);while(M(j.opaqueBits,j.requirementsForBottomUp));I("worker","initializing and pre-simplifying took",performance.now()-t,"ms");const o=performance.now();N(j.opaqueBits,j.requirementsForBottomUp),I("worker","fixpoint propagation took",performance.now()-o,"ms");break}case"analyze":{if(!j)throw new Error("needs to be initialized first!!!!");const n=H(e.data.checkId);I("worker","total time for",e.data.checkId,"was",performance.now()-t,"ms"),postMessage({checkId:e.data.checkId,expression:G(n)})}}};function H(e){const t=j.logic.itemBits[e],n=j.requirementsForBottomUp[t].removeDuplicates(),i=performance.now(),o=k(j.logic,n.conjunctions);return I("  ","worker","simplifying took",performance.now()-i,"ms"),o}})();
